// Code generated by moq; DO NOT EDIT.
// github.com/matryer/moq

package mock

import (
	"context"
	"github.com/ONSdigital/dp-kafka/v3/interfaces"
	"sync"
)

// Ensure, that MessageMock does implement interfaces.Message.
// If this is not the case, regenerate this file with moq.
var _ interfaces.Message = &MessageMock{}

// MessageMock is a mock implementation of interfaces.Message.
//
//	func TestSomethingThatUsesMessage(t *testing.T) {
//
//		// make and configure a mocked interfaces.Message
//		mockedMessage := &MessageMock{
//			CommitFunc: func()  {
//				panic("mock out the Commit method")
//			},
//			CommitAndReleaseFunc: func()  {
//				panic("mock out the CommitAndRelease method")
//			},
//			ContextFunc: func() context.Context {
//				panic("mock out the Context method")
//			},
//			GetDataFunc: func() []byte {
//				panic("mock out the GetData method")
//			},
//			GetHeaderFunc: func(key string) string {
//				panic("mock out the GetHeader method")
//			},
//			MarkFunc: func()  {
//				panic("mock out the Mark method")
//			},
//			OffsetFunc: func() int64 {
//				panic("mock out the Offset method")
//			},
//			ReleaseFunc: func()  {
//				panic("mock out the Release method")
//			},
//			UpstreamDoneFunc: func() chan struct{} {
//				panic("mock out the UpstreamDone method")
//			},
//		}
//
//		// use mockedMessage in code that requires interfaces.Message
//		// and then make assertions.
//
//	}
type MessageMock struct {
	// CommitFunc mocks the Commit method.
	CommitFunc func()

	// CommitAndReleaseFunc mocks the CommitAndRelease method.
	CommitAndReleaseFunc func()

	// ContextFunc mocks the Context method.
	ContextFunc func() context.Context

	// GetDataFunc mocks the GetData method.
	GetDataFunc func() []byte

	// GetHeaderFunc mocks the GetHeader method.
	GetHeaderFunc func(key string) string

	// MarkFunc mocks the Mark method.
	MarkFunc func()

	// OffsetFunc mocks the Offset method.
	OffsetFunc func() int64

	// ReleaseFunc mocks the Release method.
	ReleaseFunc func()

	// UpstreamDoneFunc mocks the UpstreamDone method.
	UpstreamDoneFunc func() chan struct{}

	// calls tracks calls to the methods.
	calls struct {
		// Commit holds details about calls to the Commit method.
		Commit []struct {
		}
		// CommitAndRelease holds details about calls to the CommitAndRelease method.
		CommitAndRelease []struct {
		}
		// Context holds details about calls to the Context method.
		Context []struct {
		}
		// GetData holds details about calls to the GetData method.
		GetData []struct {
		}
		// GetHeader holds details about calls to the GetHeader method.
		GetHeader []struct {
			// Key is the key argument value.
			Key string
		}
		// Mark holds details about calls to the Mark method.
		Mark []struct {
		}
		// Offset holds details about calls to the Offset method.
		Offset []struct {
		}
		// Release holds details about calls to the Release method.
		Release []struct {
		}
		// UpstreamDone holds details about calls to the UpstreamDone method.
		UpstreamDone []struct {
		}
	}
	lockCommit           sync.RWMutex
	lockCommitAndRelease sync.RWMutex
	lockContext          sync.RWMutex
	lockGetData          sync.RWMutex
	lockGetHeader        sync.RWMutex
	lockMark             sync.RWMutex
	lockOffset           sync.RWMutex
	lockRelease          sync.RWMutex
	lockUpstreamDone     sync.RWMutex
}

// Commit calls CommitFunc.
func (mock *MessageMock) Commit() {
	if mock.CommitFunc == nil {
		panic("MessageMock.CommitFunc: method is nil but Message.Commit was just called")
	}
	callInfo := struct {
	}{}
	mock.lockCommit.Lock()
	mock.calls.Commit = append(mock.calls.Commit, callInfo)
	mock.lockCommit.Unlock()
	mock.CommitFunc()
}

// CommitCalls gets all the calls that were made to Commit.
// Check the length with:
//
//	len(mockedMessage.CommitCalls())
func (mock *MessageMock) CommitCalls() []struct {
} {
	var calls []struct {
	}
	mock.lockCommit.RLock()
	calls = mock.calls.Commit
	mock.lockCommit.RUnlock()
	return calls
}

// CommitAndRelease calls CommitAndReleaseFunc.
func (mock *MessageMock) CommitAndRelease() {
	if mock.CommitAndReleaseFunc == nil {
		panic("MessageMock.CommitAndReleaseFunc: method is nil but Message.CommitAndRelease was just called")
	}
	callInfo := struct {
	}{}
	mock.lockCommitAndRelease.Lock()
	mock.calls.CommitAndRelease = append(mock.calls.CommitAndRelease, callInfo)
	mock.lockCommitAndRelease.Unlock()
	mock.CommitAndReleaseFunc()
}

// CommitAndReleaseCalls gets all the calls that were made to CommitAndRelease.
// Check the length with:
//
//	len(mockedMessage.CommitAndReleaseCalls())
func (mock *MessageMock) CommitAndReleaseCalls() []struct {
} {
	var calls []struct {
	}
	mock.lockCommitAndRelease.RLock()
	calls = mock.calls.CommitAndRelease
	mock.lockCommitAndRelease.RUnlock()
	return calls
}

// Context calls ContextFunc.
func (mock *MessageMock) Context() context.Context {
	if mock.ContextFunc == nil {
		panic("MessageMock.ContextFunc: method is nil but Message.Context was just called")
	}
	callInfo := struct {
	}{}
	mock.lockContext.Lock()
	mock.calls.Context = append(mock.calls.Context, callInfo)
	mock.lockContext.Unlock()
	return mock.ContextFunc()
}

// ContextCalls gets all the calls that were made to Context.
// Check the length with:
//
//	len(mockedMessage.ContextCalls())
func (mock *MessageMock) ContextCalls() []struct {
} {
	var calls []struct {
	}
	mock.lockContext.RLock()
	calls = mock.calls.Context
	mock.lockContext.RUnlock()
	return calls
}

// GetData calls GetDataFunc.
func (mock *MessageMock) GetData() []byte {
	if mock.GetDataFunc == nil {
		panic("MessageMock.GetDataFunc: method is nil but Message.GetData was just called")
	}
	callInfo := struct {
	}{}
	mock.lockGetData.Lock()
	mock.calls.GetData = append(mock.calls.GetData, callInfo)
	mock.lockGetData.Unlock()
	return mock.GetDataFunc()
}

// GetDataCalls gets all the calls that were made to GetData.
// Check the length with:
//
//	len(mockedMessage.GetDataCalls())
func (mock *MessageMock) GetDataCalls() []struct {
} {
	var calls []struct {
	}
	mock.lockGetData.RLock()
	calls = mock.calls.GetData
	mock.lockGetData.RUnlock()
	return calls
}

// GetHeader calls GetHeaderFunc.
func (mock *MessageMock) GetHeader(key string) string {
	if mock.GetHeaderFunc == nil {
		panic("MessageMock.GetHeaderFunc: method is nil but Message.GetHeader was just called")
	}
	callInfo := struct {
		Key string
	}{
		Key: key,
	}
	mock.lockGetHeader.Lock()
	mock.calls.GetHeader = append(mock.calls.GetHeader, callInfo)
	mock.lockGetHeader.Unlock()
	return mock.GetHeaderFunc(key)
}

// GetHeaderCalls gets all the calls that were made to GetHeader.
// Check the length with:
//
//	len(mockedMessage.GetHeaderCalls())
func (mock *MessageMock) GetHeaderCalls() []struct {
	Key string
} {
	var calls []struct {
		Key string
	}
	mock.lockGetHeader.RLock()
	calls = mock.calls.GetHeader
	mock.lockGetHeader.RUnlock()
	return calls
}

// Mark calls MarkFunc.
func (mock *MessageMock) Mark() {
	if mock.MarkFunc == nil {
		panic("MessageMock.MarkFunc: method is nil but Message.Mark was just called")
	}
	callInfo := struct {
	}{}
	mock.lockMark.Lock()
	mock.calls.Mark = append(mock.calls.Mark, callInfo)
	mock.lockMark.Unlock()
	mock.MarkFunc()
}

// MarkCalls gets all the calls that were made to Mark.
// Check the length with:
//
//	len(mockedMessage.MarkCalls())
func (mock *MessageMock) MarkCalls() []struct {
} {
	var calls []struct {
	}
	mock.lockMark.RLock()
	calls = mock.calls.Mark
	mock.lockMark.RUnlock()
	return calls
}

// Offset calls OffsetFunc.
func (mock *MessageMock) Offset() int64 {
	if mock.OffsetFunc == nil {
		panic("MessageMock.OffsetFunc: method is nil but Message.Offset was just called")
	}
	callInfo := struct {
	}{}
	mock.lockOffset.Lock()
	mock.calls.Offset = append(mock.calls.Offset, callInfo)
	mock.lockOffset.Unlock()
	return mock.OffsetFunc()
}

// OffsetCalls gets all the calls that were made to Offset.
// Check the length with:
//
//	len(mockedMessage.OffsetCalls())
func (mock *MessageMock) OffsetCalls() []struct {
} {
	var calls []struct {
	}
	mock.lockOffset.RLock()
	calls = mock.calls.Offset
	mock.lockOffset.RUnlock()
	return calls
}

// Release calls ReleaseFunc.
func (mock *MessageMock) Release() {
	if mock.ReleaseFunc == nil {
		panic("MessageMock.ReleaseFunc: method is nil but Message.Release was just called")
	}
	callInfo := struct {
	}{}
	mock.lockRelease.Lock()
	mock.calls.Release = append(mock.calls.Release, callInfo)
	mock.lockRelease.Unlock()
	mock.ReleaseFunc()
}

// ReleaseCalls gets all the calls that were made to Release.
// Check the length with:
//
//	len(mockedMessage.ReleaseCalls())
func (mock *MessageMock) ReleaseCalls() []struct {
} {
	var calls []struct {
	}
	mock.lockRelease.RLock()
	calls = mock.calls.Release
	mock.lockRelease.RUnlock()
	return calls
}

// UpstreamDone calls UpstreamDoneFunc.
func (mock *MessageMock) UpstreamDone() chan struct{} {
	if mock.UpstreamDoneFunc == nil {
		panic("MessageMock.UpstreamDoneFunc: method is nil but Message.UpstreamDone was just called")
	}
	callInfo := struct {
	}{}
	mock.lockUpstreamDone.Lock()
	mock.calls.UpstreamDone = append(mock.calls.UpstreamDone, callInfo)
	mock.lockUpstreamDone.Unlock()
	return mock.UpstreamDoneFunc()
}

// UpstreamDoneCalls gets all the calls that were made to UpstreamDone.
// Check the length with:
//
//	len(mockedMessage.UpstreamDoneCalls())
func (mock *MessageMock) UpstreamDoneCalls() []struct {
} {
	var calls []struct {
	}
	mock.lockUpstreamDone.RLock()
	calls = mock.calls.UpstreamDone
	mock.lockUpstreamDone.RUnlock()
	return calls
}
