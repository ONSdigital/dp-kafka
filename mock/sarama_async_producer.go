// Code generated by moq; DO NOT EDIT.
// github.com/matryer/moq

package mock

import (
	"github.com/ONSdigital/dp-kafka"
	"github.com/Shopify/sarama"
	"sync"
)

var (
	lockAsyncProducerMockAsyncClose sync.RWMutex
	lockAsyncProducerMockClose      sync.RWMutex
	lockAsyncProducerMockErrors     sync.RWMutex
	lockAsyncProducerMockInput      sync.RWMutex
	lockAsyncProducerMockSuccesses  sync.RWMutex
)

// Ensure, that AsyncProducerMock does implement kafka.AsyncProducer.
// If this is not the case, regenerate this file with moq.
var _ kafka.AsyncProducer = &AsyncProducerMock{}

// AsyncProducerMock is a mock implementation of kafka.AsyncProducer.
//
//     func TestSomethingThatUsesAsyncProducer(t *testing.T) {
//
//         // make and configure a mocked kafka.AsyncProducer
//         mockedAsyncProducer := &AsyncProducerMock{
//             AsyncCloseFunc: func()  {
// 	               panic("mock out the AsyncClose method")
//             },
//             CloseFunc: func() error {
// 	               panic("mock out the Close method")
//             },
//             ErrorsFunc: func() <-chan *sarama.ProducerError {
// 	               panic("mock out the Errors method")
//             },
//             InputFunc: func() chan<- *sarama.ProducerMessage {
// 	               panic("mock out the Input method")
//             },
//             SuccessesFunc: func() <-chan *sarama.ProducerMessage {
// 	               panic("mock out the Successes method")
//             },
//         }
//
//         // use mockedAsyncProducer in code that requires kafka.AsyncProducer
//         // and then make assertions.
//
//     }
type AsyncProducerMock struct {
	// AsyncCloseFunc mocks the AsyncClose method.
	AsyncCloseFunc func()

	// CloseFunc mocks the Close method.
	CloseFunc func() error

	// ErrorsFunc mocks the Errors method.
	ErrorsFunc func() <-chan *sarama.ProducerError

	// InputFunc mocks the Input method.
	InputFunc func() chan<- *sarama.ProducerMessage

	// SuccessesFunc mocks the Successes method.
	SuccessesFunc func() <-chan *sarama.ProducerMessage

	// calls tracks calls to the methods.
	calls struct {
		// AsyncClose holds details about calls to the AsyncClose method.
		AsyncClose []struct {
		}
		// Close holds details about calls to the Close method.
		Close []struct {
		}
		// Errors holds details about calls to the Errors method.
		Errors []struct {
		}
		// Input holds details about calls to the Input method.
		Input []struct {
		}
		// Successes holds details about calls to the Successes method.
		Successes []struct {
		}
	}
}

// AsyncClose calls AsyncCloseFunc.
func (mock *AsyncProducerMock) AsyncClose() {
	if mock.AsyncCloseFunc == nil {
		panic("AsyncProducerMock.AsyncCloseFunc: method is nil but AsyncProducer.AsyncClose was just called")
	}
	callInfo := struct {
	}{}
	lockAsyncProducerMockAsyncClose.Lock()
	mock.calls.AsyncClose = append(mock.calls.AsyncClose, callInfo)
	lockAsyncProducerMockAsyncClose.Unlock()
	mock.AsyncCloseFunc()
}

// AsyncCloseCalls gets all the calls that were made to AsyncClose.
// Check the length with:
//     len(mockedAsyncProducer.AsyncCloseCalls())
func (mock *AsyncProducerMock) AsyncCloseCalls() []struct {
} {
	var calls []struct {
	}
	lockAsyncProducerMockAsyncClose.RLock()
	calls = mock.calls.AsyncClose
	lockAsyncProducerMockAsyncClose.RUnlock()
	return calls
}

// Close calls CloseFunc.
func (mock *AsyncProducerMock) Close() error {
	if mock.CloseFunc == nil {
		panic("AsyncProducerMock.CloseFunc: method is nil but AsyncProducer.Close was just called")
	}
	callInfo := struct {
	}{}
	lockAsyncProducerMockClose.Lock()
	mock.calls.Close = append(mock.calls.Close, callInfo)
	lockAsyncProducerMockClose.Unlock()
	return mock.CloseFunc()
}

// CloseCalls gets all the calls that were made to Close.
// Check the length with:
//     len(mockedAsyncProducer.CloseCalls())
func (mock *AsyncProducerMock) CloseCalls() []struct {
} {
	var calls []struct {
	}
	lockAsyncProducerMockClose.RLock()
	calls = mock.calls.Close
	lockAsyncProducerMockClose.RUnlock()
	return calls
}

// Errors calls ErrorsFunc.
func (mock *AsyncProducerMock) Errors() <-chan *sarama.ProducerError {
	if mock.ErrorsFunc == nil {
		panic("AsyncProducerMock.ErrorsFunc: method is nil but AsyncProducer.Errors was just called")
	}
	callInfo := struct {
	}{}
	lockAsyncProducerMockErrors.Lock()
	mock.calls.Errors = append(mock.calls.Errors, callInfo)
	lockAsyncProducerMockErrors.Unlock()
	return mock.ErrorsFunc()
}

// ErrorsCalls gets all the calls that were made to Errors.
// Check the length with:
//     len(mockedAsyncProducer.ErrorsCalls())
func (mock *AsyncProducerMock) ErrorsCalls() []struct {
} {
	var calls []struct {
	}
	lockAsyncProducerMockErrors.RLock()
	calls = mock.calls.Errors
	lockAsyncProducerMockErrors.RUnlock()
	return calls
}

// Input calls InputFunc.
func (mock *AsyncProducerMock) Input() chan<- *sarama.ProducerMessage {
	if mock.InputFunc == nil {
		panic("AsyncProducerMock.InputFunc: method is nil but AsyncProducer.Input was just called")
	}
	callInfo := struct {
	}{}
	lockAsyncProducerMockInput.Lock()
	mock.calls.Input = append(mock.calls.Input, callInfo)
	lockAsyncProducerMockInput.Unlock()
	return mock.InputFunc()
}

// InputCalls gets all the calls that were made to Input.
// Check the length with:
//     len(mockedAsyncProducer.InputCalls())
func (mock *AsyncProducerMock) InputCalls() []struct {
} {
	var calls []struct {
	}
	lockAsyncProducerMockInput.RLock()
	calls = mock.calls.Input
	lockAsyncProducerMockInput.RUnlock()
	return calls
}

// Successes calls SuccessesFunc.
func (mock *AsyncProducerMock) Successes() <-chan *sarama.ProducerMessage {
	if mock.SuccessesFunc == nil {
		panic("AsyncProducerMock.SuccessesFunc: method is nil but AsyncProducer.Successes was just called")
	}
	callInfo := struct {
	}{}
	lockAsyncProducerMockSuccesses.Lock()
	mock.calls.Successes = append(mock.calls.Successes, callInfo)
	lockAsyncProducerMockSuccesses.Unlock()
	return mock.SuccessesFunc()
}

// SuccessesCalls gets all the calls that were made to Successes.
// Check the length with:
//     len(mockedAsyncProducer.SuccessesCalls())
func (mock *AsyncProducerMock) SuccessesCalls() []struct {
} {
	var calls []struct {
	}
	lockAsyncProducerMockSuccesses.RLock()
	calls = mock.calls.Successes
	lockAsyncProducerMockSuccesses.RUnlock()
	return calls
}
